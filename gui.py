
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer

import cv2
import math as m
import mediapipe as mp
import numpy as np
import pandas as pd
from tkinter import Tk, filedialog, Toplevel, Label, Button
import time
import os
import webbrowser
import sys
from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage


# Adjust the path for assets
if getattr(sys, 'frozen', False):
    OUTPUT_PATH = Path(sys.executable).parent
else:
    OUTPUT_PATH = Path(__file__).parent

ASSETS_PATH = OUTPUT_PATH / "assets" / "frame0"


def relative_to_assets(path: str) -> Path:
    return ASSETS_PATH / Path(path)

def open_vanessa_link(event):
    webbrowser.open("http://lattes.cnpq.br/1442468348335571")

def open_link(event):
    webbrowser.open("https://www.linkedin.com/in/yuri-rudimar/")

def funcao():  
    # Configuração do MediaPipe Holistic
    mp_drawing = mp.solutions.drawing_utils
    mp_holistic = mp.solutions.holistic
    def inicio():

        status_label.config(text="STATUS: CARREGANDO...")
    
   
        window.update()
    

        window.after(2000, finalizar)

    def finalizar():
        status_label.config(text="STATUS: NO AGUARDO")

    def convert_seconds_to_hhmmss(seconds):
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        seconds = int(seconds % 60)
        return f"{hours:02}:{minutes:02}:{seconds:02}"
    
    def calculate_angle(a, b, c):
        a = np.array(a)
        b = np.array(b)
        c = np.array(c)

        radians = np.arctan2(c[1] - b[1], c[0] - b[0]) - np.arctan2(a[1] - b[1], a[0] - b[0])
        angle = np.abs(radians * 180.0 / np.pi)

        if angle > 180.0:
            angle = 360 - angle

        return angle

    def findAngle(x1, y1, x2, y2):
        theta = m.acos((y2 - y1) * (-y1) / (m.sqrt((x2 - x1)**2 + (y2 - y1)**2) * y1))
        degree = int(180 / m.pi) * theta
        return degree

    def findDistance(x1, y1, x2, y2):
        dist = m.sqrt((x2 - x1)**2 + (y2 - y1)**2)
        return dist


    def select_video_file():
        root = Tk()
        root.withdraw()  # Oculta a janela principal do tkinter imediatamente
        root.call('wm', 'attributes', '.', '-topmost', True)  # Mantém o diálogo de seleção de arquivo no topo
        video_path = filedialog.askopenfilename(title="Escolha o vídeo", filetypes=[("Video Files", "*.mp4;*.avi;*.mov")])
        root.destroy()  # Destroi a janela raiz logo após a seleção
        return video_path

    def create_loading_screen(output_path):
        loading_window = Toplevel()
        loading_window.title("Concluído")
        loading_window.geometry("300x150")
        loading_window.resizable(False, False)

        # Definir o wraplength para quebrar o texto em várias linhas
        label = Label(
            loading_window, 
            text=f"Projeto foi concluído com sucesso e salvo em {output_path}", 
            padx=20, 
            pady=20, 
            wraplength=250  # Ajuste este valor conforme necessário
        )
        label.pack()

        # Adicionar um botão para fechar a janela
        button = Button(
            loading_window, 
            text="Fechar", 
            command=loading_window.destroy
        )
        button.pack(pady=10)

        return loading_window



    video_path = select_video_file()
    if not video_path:
        print("Nenhum vídeo selecionado.")
        return

    # Criar tela de carregamento
    
    inicio()

    cap = cv2.VideoCapture(video_path)

    # Definir resolução padrão 1920x1080
    default_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    default_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    cap.set(cv2.CAP_PROP_FRAME_WIDTH, default_width)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, default_height)

    # Definir o caminho de saída para o mesmo diretório do vídeo original
    video_dir = os.path.dirname(video_path)  # Diretório do vídeo original
    output_path = os.path.join(video_dir, 'video_marked.mp4')  # Salvar no mesmo diretório

    # Criar VideoWriter para salvar o vídeo
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec para salvar o vídeo
    out = cv2.VideoWriter(output_path, fourcc, cap.get(cv2.CAP_PROP_FPS), (default_width, default_height))

    # Lista para armazenar os dados do relatório
    data = []

    # Obter a taxa de frames por segundo (fps) do vídeo
    fps = cap.get(cv2.CAP_PROP_FPS)
    # Inicializar uma variável para armazenar o último segundo registrado
    last_second = -1

    with mp_holistic.Holistic(min_detection_confidence=0.5, min_tracking_confidence=0.5) as holistic:
        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                print("Fim do vídeo.")
                break

            image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            results = holistic.process(image)

            # Conversão de volta para BGR para exibir com OpenCV
            image = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)

            # Obter as dimensões da imagem
            height, width, _ = image.shape


            if results.pose_landmarks:
                landmarks = results.pose_landmarks.landmark
                # Definir pontos para ombro e quadril (direito e esquerdo) com conversão para coordenadas de pixels
            left_shoulder = [int(landmarks[mp_holistic.PoseLandmark.LEFT_SHOULDER.value].x * width),
                                int(landmarks[mp_holistic.PoseLandmark.LEFT_SHOULDER.value].y * height)]
            left_hip = [int(landmarks[mp_holistic.PoseLandmark.LEFT_HIP.value].x * width),
                            int(landmarks[mp_holistic.PoseLandmark.LEFT_HIP.value].y * height)]
            right_shoulder = [int(landmarks[mp_holistic.PoseLandmark.RIGHT_SHOULDER.value].x * width),
                                int(landmarks[mp_holistic.PoseLandmark.RIGHT_SHOULDER.value].y * height)]
            right_hip = [int(landmarks[mp_holistic.PoseLandmark.RIGHT_HIP.value].x * width),
                            int(landmarks[mp_holistic.PoseLandmark.RIGHT_HIP.value].y * height)]
            left_ear = [int(landmarks[mp_holistic.PoseLandmark.LEFT_EAR.value].x * width),
                            int(landmarks[mp_holistic.PoseLandmark.LEFT_EAR.value].y * height)]
            right_ear = [int(landmarks[mp_holistic.PoseLandmark.RIGHT_EAR.value].x * width),
                            int(landmarks[mp_holistic.PoseLandmark.RIGHT_EAR.value].y * height)]
            elbow_left = [int(landmarks[mp_holistic.PoseLandmark.LEFT_ELBOW.value].x * width), int(landmarks[mp_holistic.PoseLandmark.LEFT_ELBOW.value].y * height)]
            wrist_left = [int(landmarks[mp_holistic.PoseLandmark.LEFT_WRIST.value].x * width), int(landmarks[mp_holistic.PoseLandmark.LEFT_WRIST.value].y * height)]            
            elbow_right = [int(landmarks[mp_holistic.PoseLandmark.RIGHT_ELBOW.value].x * width), int(landmarks[mp_holistic.PoseLandmark.RIGHT_ELBOW.value].y * height)]
            wrist_right = [int(landmarks[mp_holistic.PoseLandmark.RIGHT_WRIST.value].x * width), int(landmarks[mp_holistic.PoseLandmark.RIGHT_WRIST.value].y * height)]

                # Exibir apenas os pontos visíveis
            left_visibility = landmarks[mp_holistic.PoseLandmark.LEFT_SHOULDER.value].visibility
            right_visibility = landmarks[mp_holistic.PoseLandmark.RIGHT_SHOULDER.value].visibility

                            # Usar a média dos ombros para definir a base do pescoço
            neck_base = ((left_shoulder[0] + right_shoulder[0]) / 2, 
                            (left_shoulder[1] + right_shoulder[1]) / 2)

                            # Obter o tempo atual do vídeo em segundos
            frame_number = cap.get(cv2.CAP_PROP_POS_FRAMES)
            current_time_seconds  = frame_number / fps
            current_time_hhmmss = convert_seconds_to_hhmmss(current_time_seconds)

                        # Verificar se o segundo atual é diferente do último segundo registrado

            if left_visibility > right_visibility:
                left_angle_tronco = calculate_angle(left_shoulder, left_hip, [left_hip[0], left_hip[1] - 1])
                cv2.putText(image, f'Ang. Tronco: {int(left_angle_tronco)}',
                                (50, 50),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                    
                cv2.circle(image, tuple(left_shoulder), 5, (0, 255, 0), -1)
                cv2.circle(image, tuple(left_hip), 5, (0, 255, 0), -1)
                cv2.line(image, tuple(left_hip), tuple(left_shoulder), (0, 255, 0), 2)

                if left_angle_tronco <= 5:
                    rula_score_tronco = 1
                elif left_angle_tronco > 5 and left_angle_tronco <= 20:
                    rula_score_tronco = 2
                elif left_angle_tronco > 20 and left_angle_tronco <=60:
                    rula_score_tronco = 3
                elif left_angle_tronco > 60:
                    rula_score_tronco = 4 

                cv2.putText(image, f'Rula Score: {int(rula_score_tronco)}',
                            (350, 50),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                
                #Angulo Pescoco 

                left_neck_angle = findAngle(neck_base[0], neck_base[1], left_ear[0], left_ear[1]) 
                cv2.putText(image, f'Ang. Pescoco: {int(left_neck_angle)}', (50, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA) 
                cv2.circle(image, (int(left_ear[0]), int(left_ear[1])), 10, (0, 255, 0), -1)
                cv2.line(image, (int(left_ear[0]), int(left_ear[1])), (int(left_shoulder[0]), int(left_shoulder[1])), (0, 255, 0), 2)
                
                if left_neck_angle > 0 and left_neck_angle <= 10:
                    rula_score_pescoco = 1 
                elif left_neck_angle > 10 and left_neck_angle <=20: 
                    rula_score_pescoco = 2
                elif left_neck_angle > 20:
                    rula_score_pescoco = 3     

                cv2.putText(image, f'Rula Score: {int(rula_score_pescoco)}',
                            (350, 100),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                
                #Angulo Antebraco

                angle_left_antebraco = calculate_angle(left_shoulder, elbow_left, wrist_left) 

                cv2.putText(image, f'Ang. AntBr.: {int(angle_left_antebraco)}',
                                (50, 150),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                    
                cv2.circle(image, tuple(elbow_left), 5, (0, 255, 0), -1)
                cv2.circle(image, tuple(wrist_left), 5, (0, 255, 0), -1)
                cv2.line(image, tuple(left_shoulder), tuple(elbow_left), (0, 255, 0), 2)
                cv2.line(image, tuple(elbow_left), tuple(wrist_left), (0, 255, 0), 2)
                # Classificação do método RULA com base no ângulo
                if angle_left_antebraco > 60 and angle_left_antebraco < 100:
                    rula_score_antebraco = 1  # Braço apoiado
                elif angle_left_antebraco < 60 or angle_left_antebraco > 100:
                    rula_score_antebraco = 2

                cv2.putText(image, f'Rula Score: {int(rula_score_antebraco)}',
                                (350, 150),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

                #angulo braco 

                left_angle_braco = calculate_angle(left_hip, left_shoulder, wrist_left)

                cv2.putText(image, f'Ang. Braco: {int(left_angle_braco)}',
                            (50, 200),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                
                # Classificação do método RULA com base no ângulo
                if left_angle_braco <= 20:
                    rula_score_braco = 1  # Braço apoiado
                elif left_angle_braco > 20 and left_angle_braco <= 45:
                    rula_score_braco = 2
                elif left_angle_braco > 45 and left_angle_braco <= 90:
                    rula_score_braco = 3
                elif left_angle_braco > 90:
                    rula_score_braco = 4

                cv2.putText(image, f'Rula Score: {int(rula_score_braco)}',
                    (350, 200),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

                                # Adicionar os dados de ângulo ao relatório
                data.append({
                    'Tempo (s)': current_time_hhmmss,
                    'Ângulo Tronco Esquerdo': left_angle_tronco,
                    'Ângulo Tronco Direito': 0,
                    'Rula Score Tronco': rula_score_tronco,
                    'Ângulo AnteBraco Esquerdo': angle_left_antebraco,
                    'Ângulo AnteBraco Direito':0,
                    'Rula Score AnteBraco': rula_score_antebraco,
                    'Ângulo Pescoco Esquerdo': left_neck_angle,
                    'Ângulo Pescoco Direito': 0,
                    'Rula Score Pescoco': rula_score_pescoco,
                    'Ângulo Braco Esquerdo':left_angle_braco,
                    'Ângulo Braco Direito':0,
                    'Rula Score Braco':rula_score_braco,
                })


            elif right_visibility > left_visibility:
                
                right_angle_tronco = calculate_angle(right_shoulder, right_hip, [right_hip[0], right_hip[1] - 1])
                cv2.putText(image, f'Ang. Tronco: {int(right_angle_tronco)}',
                                (50, 50),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                    
                cv2.circle(image, tuple(right_shoulder), 5, (0, 255, 0), -1)
                cv2.circle(image, tuple(right_hip), 5, (0, 255, 0), -1)
                cv2.line(image, tuple(right_hip), tuple(right_shoulder), (0, 255, 0), 2)

                if right_angle_tronco <= 5:
                    rula_score_tronco = 1
                elif right_angle_tronco > 5 and right_angle_tronco <= 20:
                    rula_score_tronco = 2
                elif right_angle_tronco > 20 and right_angle_tronco <= 60:
                    rula_score_tronco = 3
                elif right_angle_tronco > 60:
                    rula_score_tronco = 4 

                cv2.putText(image, f'Rula Score: {int(rula_score_tronco)}',
                            (350, 50),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                
                # Angulo Pescoco 

                right_neck_angle = findAngle(neck_base[0], neck_base[1], right_ear[0], right_ear[1]) 
                cv2.putText(image, f'Ang. Pescoco: {int(right_neck_angle)}', (50, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA) 
                cv2.circle(image, (int(right_ear[0]), int(right_ear[1])), 10, (0, 255, 0), -1)
                cv2.line(image, (int(right_ear[0]), int(right_ear[1])), (int(right_shoulder[0]), int(right_shoulder[1])), (0, 255, 0), 2)
                
                if right_neck_angle > 0 and right_neck_angle <= 10:
                    rula_score_pescoco = 1 
                elif right_neck_angle > 10 and right_neck_angle <= 20: 
                    rula_score_pescoco = 2
                elif right_neck_angle > 20:
                    rula_score_pescoco = 3     

                cv2.putText(image, f'Rula Score: {int(rula_score_pescoco)}',
                            (350, 100),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                
                # Angulo Antebraco

                angle_right_antebraco = calculate_angle(right_shoulder, elbow_right, wrist_right) 

                cv2.putText(image, f'Ang. AntBr.: {int(angle_right_antebraco)}',
                                (50, 150),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                    
                cv2.circle(image, tuple(elbow_right), 5, (0, 255, 0), -1)
                cv2.circle(image, tuple(wrist_right), 5, (0, 255, 0), -1)
                cv2.line(image, tuple(right_shoulder), tuple(elbow_right), (0, 255, 0), 2)
                cv2.line(image, tuple(elbow_right), tuple(wrist_right), (0, 255, 0), 2)
                # Classificação do método RULA com base no ângulo
                if angle_right_antebraco > 60 and angle_right_antebraco < 100:
                    rula_score_antebraco = 1  # Braço apoiado
                elif angle_right_antebraco < 60 or angle_right_antebraco > 100:
                    rula_score_antebraco = 2

                cv2.putText(image, f'Rula Score: {int(rula_score_antebraco)}',
                                (350, 150),
                                cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

                # Angulo braco 

                right_angle_braco = calculate_angle(right_hip, right_shoulder, wrist_right)

                cv2.putText(image, f'Ang. Braco: {int(right_angle_braco)}',
                            (50, 200),
                            cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)
                
                # Classificação do método RULA com base no ângulo
                if right_angle_braco <= 20:
                    rula_score_braco = 1  # Braço apoiado
                elif right_angle_braco > 20 and right_angle_braco <= 45:
                    rula_score_braco = 2
                elif right_angle_braco > 45 and right_angle_braco <= 90:
                    rula_score_braco = 3
                elif right_angle_braco > 90:
                    rula_score_braco = 4

                cv2.putText(image, f'Rula Score: {int(rula_score_braco)}',
                    (350, 200),
                    cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)

                data.append({
                    'Tempo (s)': current_time_hhmmss,
                    'Ângulo Tronco Esquerdo': 0,
                    'Ângulo Tronco Direito': right_angle_tronco,
                    'Rula Score Tronco': rula_score_tronco,
                    'Ângulo AnteBraco Esquerdo': 0,
                    'Ângulo AnteBraco Direito':angle_right_antebraco,
                    'Rula Score AnteBraco': rula_score_antebraco,
                    'Ângulo Pescoco Esquerdo': 0,
                    'Ângulo Pescoco Direito': right_neck_angle,
                    'Rula Score Pescoco': rula_score_pescoco,
                    'Ângulo Braco Esquerdo':right_angle_braco,
                    'Ângulo Braco Direito':0,
                    'Rula Score Braco':rula_score_braco,
                })




            # Salvar o frame processado no vídeo de saída
            out.write(image)

    cap.release()
    out.release()  # Libera o VideoWriter

    # Fechar a tela de carregamento
    create_loading_screen(output_path)

    # Criar DataFrame do Pandas e salvar como Excel no mesmo diretório
    report_path_media = os.path.join(video_dir, 'relatorio_angulo_median.xlsx')
    report_path2 = os.path.join(video_dir, 'relatorio_angulo.xlsx')
    df = pd.DataFrame(data)
    df_grouped = df.groupby('Tempo (s)').median().reset_index()
    df_grouped.to_excel(report_path_media, index=False)
    df.to_excel(report_path2, index=False)


    finalizar()
    print(f"Relatório gerado: '{report_path_media}'")
    print(f"Vídeo salvo como: '{output_path}'")


window = Tk()
window.title("Método Rula")

window.geometry("800x600")
window.configure(bg = "#FFFFFF")


canvas = Canvas(
    window,
    bg = "#FFFFFF",
    height = 600,
    width = 800,
    bd = 0,
    highlightthickness = 0,
    relief = "ridge"
)

canvas.place(x = 0, y = 0)
image_image_1 = PhotoImage(
    file=relative_to_assets("image_1.png"))
image_1 = canvas.create_image(
    90.0,
    31.0,
    image=image_image_1
)

image_image_2 = PhotoImage(
    file=relative_to_assets("image_2.png"))
image_2 = canvas.create_image(
    767.0,
    100.0,
    image=image_image_2
)

canvas.create_text(
    197.0,
    105.0,
    anchor="nw",
    text="MÉTODO RULA ",
    fill="#149B56",
    font=("Inter ExtraBold", 40 * -1)
)

image_image_3 = PhotoImage(
    file=relative_to_assets("image_3.png"))
image_3 = canvas.create_image(
    100,
    600,
    image=image_image_3
)

# Adiciona o texto "Desenvolvido por Yuri Rocha" com link
yuri_text = canvas.create_text(
    520.0,
    560.0,  # Posição ajustada para baixo da tela
    anchor="nw",
    text="Desenvolvido por Yuri Rocha com apoio de",
    fill="black",
    font=("Inter", 10),
    tags="yuri_link"  # Cria uma tag para identificar o texto clicável
)

canvas.create_line(620, 575, 685, 575, fill="black")  # Posição (x1, y1, x2, y2)

vanessa_text = canvas.create_text(
    520.0,
    575.0,  # Logo abaixo do texto anterior
    anchor="nw",
    text="Vanessa Nappi para a Disciplina de Ergonomia",
    fill="black",
    font=("Inter", 10),
    tags="vanessa_link"  # Cria uma tag para identificar o texto clicável
)

canvas.create_line(520, 590, 608, 590, fill="black")  # Posição (x1, y1, x2, y2)

canvas.tag_bind("yuri_link", "<Button-1>", open_link)
canvas.tag_bind("vanessa_link", "<Button-1>", open_vanessa_link)




image_image_4 = PhotoImage(
    file=relative_to_assets("image_4.png"))
image_4 = canvas.create_image(
    373.0,
    346.0,
    image=image_image_4
)

button_image_2 = PhotoImage(
    file=relative_to_assets("button_2.png"))
button_2 = Button(
    image=button_image_2,
    borderwidth=0,
    highlightthickness=0,
    command=funcao,
    relief="flat"
)
button_2.place(
    x=257.0,
    y=395.0,
    width=232.0,
    height=38.0
)

image_image_5 = PhotoImage(
    file=relative_to_assets("image_5.png"))
image_5 = canvas.create_image(
    375.0,
    310.0,
    image=image_image_5
)

# Adicionando o campo de STATUS abaixo do botão
status_label = Label(window, text="STATUS: AGUARDANDO", bg="#FFFFFF", font=("Inter", 12))
status_label.place(x=271.0, y=500.0)

window.resizable(False, False)
window.mainloop()
